{"version":3,"file":"ej2-compression.min.js","sources":["../../node_modules/@syncfusion/ej2-file-utils/dist/src/es5/encoding.js","../../node_modules/@syncfusion/ej2-file-utils/dist/src/es5/save.js","../../node_modules/@syncfusion/ej2-file-utils/dist/src/es5/stream-writer.js","../src/es5/compression-writer.js","../src/es5/zip-archive.js"],"sourcesContent":["/**\n * Encoding class: Contains the details about encoding type, whether to write a Unicode byte order mark (BOM).\n * ```typescript\n * let encoding : Encoding = new Encoding();\n * encoding.type = 'Utf8';\n * encoding.getBytes('Encoding', 0, 5);\n * ```\n */\nvar Encoding = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the Encoding class. A parameter specifies whether to write a Unicode byte order mark\n     * @param  {boolean} includeBom?-true to specify that a Unicode byte order mark is written; otherwise, false.\n     */\n    function Encoding(includeBom) {\n        this.emitBOM = true;\n        this.encodingType = 'Ansi';\n        this.initBOM(includeBom);\n    }\n    Object.defineProperty(Encoding.prototype, \"includeBom\", {\n        /**\n         * Gets a value indicating whether to write a Unicode byte order mark\n         * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false\n         */\n        get: function () {\n            return this.emitBOM;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Encoding.prototype, \"type\", {\n        /**\n         * Gets the encoding type.\n         * @returns EncodingType\n         */\n        get: function () {\n            return this.encodingType;\n        },\n        /**\n         * Sets the encoding type.\n         * @param  {EncodingType} value\n         */\n        set: function (value) {\n            this.encodingType = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Initialize the includeBom to emit BOM or Not\n     * @param  {boolean} includeBom\n     */\n    Encoding.prototype.initBOM = function (includeBom) {\n        if (includeBom === undefined || includeBom === null) {\n            this.emitBOM = true;\n        }\n        else {\n            this.emitBOM = includeBom;\n        }\n    };\n    /**\n     * Calculates the number of bytes produced by encoding the characters in the specified string\n     * @param  {string} chars - The string containing the set of characters to encode\n     * @returns {number} - The number of bytes produced by encoding the specified characters\n     */\n    Encoding.prototype.getByteCount = function (chars) {\n        var byteCount = 0;\n        validateNullOrUndefined(chars, 'string');\n        if (chars === '') {\n            var byte = this.utf8Len(chars.charCodeAt(0));\n            return byte;\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        return this.getByteCountInternal(chars, 0, chars.length);\n    };\n    /**\n     * Return the Byte of character\n     * @param  {number} codePoint\n     * @returns {number}\n     */\n    Encoding.prototype.utf8Len = function (codePoint) {\n        var bytes = codePoint <= 0x7F ? 1 :\n            codePoint <= 0x7FF ? 2 :\n                codePoint <= 0xFFFF ? 3 :\n                    codePoint <= 0x1FFFFF ? 4 : 0;\n        return bytes;\n    };\n    /**\n     * for 4 byte character return surrogate pair true, otherwise false\n     * @param  {number} codeUnit\n     * @returns {boolean}\n     */\n    Encoding.prototype.isHighSurrogate = function (codeUnit) {\n        return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;\n    };\n    /**\n     * for 4byte character generate the surrogate pair\n     * @param  {number} highCodeUnit\n     * @param  {number} lowCodeUnit\n     */\n    Encoding.prototype.toCodepoint = function (highCodeUnit, lowCodeUnit) {\n        highCodeUnit = (0x3FF & highCodeUnit) << 10;\n        var u = highCodeUnit | (0x3FF & lowCodeUnit);\n        return u + 0x10000;\n    };\n    /**\n     * private method to get the byte count for specific charindex and count\n     * @param  {string} chars\n     * @param  {number} charIndex\n     * @param  {number} charCount\n     */\n    Encoding.prototype.getByteCountInternal = function (chars, charIndex, charCount) {\n        var byteCount = 0;\n        if (this.encodingType === 'Utf8' || this.encodingType === 'Unicode') {\n            var isUtf8 = this.encodingType === 'Utf8';\n            for (var i = 0; i < charCount; i++) {\n                var charCode = chars.charCodeAt(isUtf8 ? charIndex : charIndex++);\n                if (this.isHighSurrogate(charCode)) {\n                    if (isUtf8) {\n                        var high = charCode;\n                        var low = chars.charCodeAt(++charIndex);\n                        byteCount += this.utf8Len(this.toCodepoint(high, low));\n                    }\n                    else {\n                        byteCount += 4;\n                        ++i;\n                    }\n                }\n                else {\n                    if (isUtf8) {\n                        byteCount += this.utf8Len(charCode);\n                    }\n                    else {\n                        byteCount += 2;\n                    }\n                }\n                if (isUtf8) {\n                    charIndex++;\n                }\n            }\n            return byteCount;\n        }\n        else {\n            byteCount = charCount;\n            return byteCount;\n        }\n    };\n    /**\n     * Encodes a set of characters from the specified string into the ArrayBuffer.\n     * @param  {string} s- The string containing the set of characters to encode\n     * @param  {number} charIndex-The index of the first character to encode.\n     * @param  {number} charCount- The number of characters to encode.\n     * @returns {ArrayBuffer} - The ArrayBuffer that contains the resulting sequence of bytes.\n     */\n    Encoding.prototype.getBytes = function (s, charIndex, charCount) {\n        validateNullOrUndefined(s, 'string');\n        validateNullOrUndefined(charIndex, 'charIndex');\n        validateNullOrUndefined(charCount, 'charCount');\n        if (charIndex < 0 || charCount < 0) {\n            throw new RangeError('Argument Out Of Range Exception: charIndex or charCount is less than zero');\n        }\n        if (s.length - charIndex < charCount) {\n            throw new RangeError('Argument Out Of Range Exception: charIndex and charCount do not denote a valid range in string');\n        }\n        var bytes;\n        if (s === '') {\n            bytes = new ArrayBuffer(0);\n            return bytes;\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        var byteCount = this.getByteCountInternal(s, charIndex, charCount);\n        switch (this.type) {\n            case 'Utf8':\n                bytes = this.getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);\n                return bytes;\n            case 'Unicode':\n                bytes = this.getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);\n                return bytes;\n            default:\n                bytes = this.getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);\n                return bytes;\n        }\n    };\n    /**\n     * Decodes a sequence of bytes from the specified ArrayBuffer into the string.\n     * @param  {ArrayBuffer} bytes- The ArrayBuffer containing the sequence of bytes to decode.\n     * @param  {number} index- The index of the first byte to decode.\n     * @param  {number} count- The number of bytes to decode.\n     * @returns {string} - The string that contains the resulting set of characters.\n     */\n    Encoding.prototype.getString = function (bytes, index, count) {\n        validateNullOrUndefined(bytes, 'bytes');\n        validateNullOrUndefined(index, 'index');\n        validateNullOrUndefined(count, 'count');\n        if (index < 0 || count < 0) {\n            throw new RangeError('Argument Out Of Range Exception: index or count is less than zero');\n        }\n        if (bytes.byteLength - index < count) {\n            throw new RangeError('Argument Out Of Range Exception: index and count do not denote a valid range in bytes');\n        }\n        if (bytes.byteLength === 0 || count === 0) {\n            return '';\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        var out = '';\n        var byteCal = new Uint8Array(bytes);\n        switch (this.type) {\n            case 'Utf8':\n                var s = this.getStringOfUtf8Encoding(byteCal, index, count);\n                return s;\n            case 'Unicode':\n                var byteUnicode = new Uint16Array(bytes);\n                out = this.getStringofUnicodeEncoding(byteUnicode, index, count);\n                return out;\n            default:\n                var j = index;\n                for (var i = 0; i < count; i++) {\n                    var c = byteCal[j];\n                    out += String.fromCharCode(c); // 1 byte(ASCII) character                  \n                    j++;\n                }\n                return out;\n        }\n    };\n    Encoding.prototype.getBytesOfAnsiEncoding = function (byteCount, s, charIndex, charCount) {\n        var bytes = new ArrayBuffer(byteCount);\n        var bufview = new Uint8Array(bytes);\n        var k = 0;\n        for (var i = 0; i < charCount; i++) {\n            var charcode = s.charCodeAt(charIndex++);\n            if (charcode < 0x800) {\n                bufview[k] = charcode;\n            }\n            else {\n                bufview[k] = 63; //replacement character '?'\n            }\n            k++;\n        }\n        return bytes;\n    };\n    Encoding.prototype.getBytesOfUtf8Encoding = function (byteCount, s, charIndex, charCount) {\n        var bytes = new ArrayBuffer(byteCount);\n        var uint = new Uint8Array(bytes);\n        var index = charIndex;\n        var j = 0;\n        for (var i = 0; i < charCount; i++) {\n            var charcode = s.charCodeAt(index);\n            if (charcode <= 0x7F) {\n                uint[j] = charcode;\n            }\n            else if (charcode < 0x800) {\n                uint[j] = 0xc0 | (charcode >> 6);\n                uint[++j] = 0x80 | (charcode & 0x3f);\n            }\n            else if ((charcode < 0xd800 || charcode >= 0xe000)) {\n                uint[j] = 0xe0 | (charcode >> 12);\n                uint[++j] = 0x80 | ((charcode >> 6) & 0x3f);\n                uint[++j] = 0x80 | (charcode & 0x3f);\n            }\n            else {\n                uint[j] = 0xef;\n                uint[++j] = 0xbf;\n                uint[++j] = 0xbd; // U+FFFE \"replacement character\"\n            }\n            ++j;\n            ++index;\n        }\n        return bytes;\n    };\n    Encoding.prototype.getBytesOfUnicodeEncoding = function (byteCount, s, charIndex, charCount) {\n        var bytes = new ArrayBuffer(byteCount);\n        var uint16 = new Uint16Array(bytes);\n        for (var i = 0; i < charCount; i++) {\n            var charcode = s.charCodeAt(i);\n            uint16[i] = charcode;\n        }\n        return bytes;\n    };\n    Encoding.prototype.getStringOfUtf8Encoding = function (byteCal, index, count) {\n        var j = 0;\n        var i = index;\n        var s = '';\n        for (j; j < count; j++) {\n            var c = byteCal[i++];\n            while (i > byteCal.length) {\n                return s;\n            }\n            if (c > 127) {\n                if (c > 191 && c < 224 && i < count) {\n                    c = (c & 31) << 6 | byteCal[i] & 63;\n                }\n                else if (c > 223 && c < 240 && i < byteCal.byteLength) {\n                    c = (c & 15) << 12 | (byteCal[i] & 63) << 6 | byteCal[++i] & 63;\n                }\n                else if (c > 239 && c < 248 && i < byteCal.byteLength) {\n                    c = (c & 7) << 18 | (byteCal[i] & 63) << 12 | (byteCal[++i] & 63) << 6 | byteCal[++i] & 63;\n                }\n                ++i;\n            }\n            s += String.fromCharCode(c); // 1 byte(ASCII) character                          \n        }\n        return s;\n    };\n    Encoding.prototype.getStringofUnicodeEncoding = function (byteUni, index, count) {\n        if (count > byteUni.length) {\n            throw new RangeError('ArgumentOutOfRange_Count');\n        }\n        var byte16 = new Uint16Array(count);\n        var out = '';\n        for (var i = 0; i < count && i < byteUni.length; i++) {\n            byte16[i] = byteUni[index++];\n        }\n        out = String.fromCharCode.apply(null, byte16);\n        return out;\n    };\n    /**\n     * To clear the encoding instance\n     * @return {void}\n     */\n    Encoding.prototype.destroy = function () {\n        this.emitBOM = undefined;\n        this.encodingType = undefined;\n    };\n    return Encoding;\n}());\nexport { Encoding };\n/**\n * To check the object is null or undefined and throw error if it is null or undefined\n * @param {Object} value - object to check is null or undefined\n * @return {boolean}\n * @throws {ArgumentException} - if the value is null or undefined\n * @private\n */\nexport function validateNullOrUndefined(value, message) {\n    if (value === null || value === undefined) {\n        throw new Error('ArgumentException: ' + message + ' cannot be null or undefined');\n    }\n}\n","/**\n * Save class provide method to save file\n * ```typescript\n * let blob : Blob = new Blob([''], { type: 'text/plain' });\n * Save.save('fileName.txt',blob);\n */\nvar Save = /** @class */ (function () {\n    /**\n     * Initialize new instance of {save}\n     */\n    function Save() {\n        // tslint:disable\n    }\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param  {string} fileName- file name to save.\n     * @param  {Blob} buffer- the content to write in file\n     * @param  {boolean} isMicrosoftBrowser- specify whether microsoft browser or not\n     * @returns {void}\n     */\n    Save.save = function (fileName, buffer) {\n        if (fileName === null || fileName === undefined || fileName === '') {\n            throw new Error('ArgumentException: fileName cannot be undefined, null or empty');\n        }\n        var extension = fileName.substring(fileName.lastIndexOf('.') + 1, fileName.length);\n        var mimeType = this.getMimeType(extension);\n        if (mimeType !== '') {\n            buffer = new Blob([buffer], { type: mimeType });\n        }\n        if (this.isMicrosoftBrowser) {\n            navigator.msSaveBlob(buffer, fileName);\n        }\n        else {\n            var downloadLink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\n            this.saveInternal(fileName, extension, buffer, downloadLink, 'download' in downloadLink);\n        }\n    };\n    Save.saveInternal = function (fileName, extension, buffer, downloadLink, hasDownloadAttribute) {\n        if (hasDownloadAttribute) {\n            downloadLink.download = fileName;\n            var dataUrl_1 = window.URL.createObjectURL(buffer);\n            downloadLink.href = dataUrl_1;\n            var event_1 = document.createEvent('MouseEvent');\n            event_1.initEvent('click', true, true);\n            downloadLink.dispatchEvent(event_1);\n            setTimeout(function () {\n                window.URL.revokeObjectURL(dataUrl_1);\n                dataUrl_1 = undefined;\n            });\n        }\n        else {\n            if (extension !== 'docx' && extension !== 'xlsx') {\n                var url = window.URL.createObjectURL(buffer);\n                var isPopupBlocked = window.open(url, '_blank');\n                if (!isPopupBlocked) {\n                    window.location.href = url;\n                }\n            }\n            else {\n                var reader_1 = new FileReader();\n                reader_1.onloadend = function () {\n                    var isPopupBlocked = window.open(reader_1.result, '_blank');\n                    if (!isPopupBlocked) {\n                        window.location.href = reader_1.result;\n                    }\n                };\n                reader_1.readAsDataURL(buffer);\n            }\n        }\n    };\n    /**\n     *\n     * @param {string} extension - get mime type of the specified extension\n     * @private\n     */\n    Save.getMimeType = function (extension) {\n        var mimeType = '';\n        switch (extension) {\n            case 'html':\n                mimeType = 'text/html';\n                break;\n            case 'pdf':\n                mimeType = 'application/pdf';\n                break;\n            case 'docx':\n                mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\n                break;\n            case 'xlsx':\n                mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';\n                break;\n            case 'txt':\n                mimeType = 'text/plain';\n                break;\n        }\n        return mimeType;\n    };\n    return Save;\n}());\nexport { Save };\n","import { Encoding, validateNullOrUndefined } from './encoding';\nimport { Save } from './save';\n/**\n * StreamWriter class contains the implementation for writing characters to a file in a particular encoding\n * ```typescript\n * let writer = new StreamWriter();\n * writer.write('Hello World');\n * writer.save('Sample.txt');\n * writer.dispose();\n * ```\n */\nvar StreamWriter = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the StreamWriter class by using the specified encoding.\n     * @param  {Encoding} encoding?- The character encoding to use.\n     */\n    function StreamWriter(encoding) {\n        this.bufferBlob = new Blob(['']);\n        this.bufferText = '';\n        this.init(encoding);\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    Object.defineProperty(StreamWriter.prototype, \"buffer\", {\n        /**\n         * Gets the content written to the StreamWriter as Blob.\n         * @returns Blob\n         */\n        get: function () {\n            this.flush();\n            return this.bufferBlob;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StreamWriter.prototype, \"encoding\", {\n        /**\n         * Gets the encoding.\n         * @returns Encoding\n         */\n        get: function () {\n            return this.enc;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    StreamWriter.prototype.init = function (encoding) {\n        if (encoding === null || encoding === undefined) {\n            this.enc = new Encoding(false);\n            this.enc.type = 'Utf8';\n        }\n        else {\n            this.enc = encoding;\n            this.setBomByte();\n        }\n    };\n    /**\n     * Private method to set Byte Order Mark(BOM) value based on EncodingType\n     */\n    StreamWriter.prototype.setBomByte = function () {\n        if (this.encoding.includeBom) {\n            switch (this.encoding.type) {\n                case 'Unicode':\n                    var arrayUnicode = new ArrayBuffer(2);\n                    var uint8 = new Uint8Array(arrayUnicode);\n                    uint8[0] = 255;\n                    uint8[1] = 254;\n                    this.bufferBlob = new Blob([arrayUnicode]);\n                    break;\n                case 'Utf8':\n                    var arrayUtf8 = new ArrayBuffer(3);\n                    var utf8 = new Uint8Array(arrayUtf8);\n                    utf8[0] = 239;\n                    utf8[1] = 187;\n                    utf8[2] = 191;\n                    this.bufferBlob = new Blob([arrayUtf8]);\n                    break;\n                default:\n                    this.bufferBlob = new Blob(['']);\n                    break;\n            }\n        }\n    };\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param  {string} fileName - The file name to save\n     * @returns {void}\n     */\n    StreamWriter.prototype.save = function (fileName) {\n        if (this.bufferText !== '') {\n            this.flush();\n        }\n        Save.save(fileName, this.buffer);\n    };\n    /**\n     * Writes the specified string.\n     * @param  {string} value - The string to write. If value is null or undefined, nothing is written.\n     * @returns {void}\n     */\n    StreamWriter.prototype.write = function (value) {\n        if (this.encoding === undefined) {\n            throw new Error('Object Disposed Exception: current writer is disposed');\n        }\n        validateNullOrUndefined(value, 'string');\n        this.bufferText += value;\n        if (this.bufferText.length >= 10240) {\n            this.flush();\n        }\n    };\n    StreamWriter.prototype.flush = function () {\n        if (this.bufferText === undefined || this.bufferText === null || this.bufferText.length === 0) {\n            return;\n        }\n        var bufferArray = this.encoding.getBytes(this.bufferText, 0, this.bufferText.length);\n        this.bufferText = '';\n        this.bufferBlob = new Blob([this.bufferBlob, bufferArray]);\n    };\n    /**\n     * Writes the specified string followed by a line terminator\n     * @param  {string} value - The string to write. If value is null or undefined, nothing is written\n     * @returns {void}\n     */\n    StreamWriter.prototype.writeLine = function (value) {\n        if (this.encoding === undefined) {\n            throw new Error('Object Disposed Exception: current writer is disposed');\n        }\n        validateNullOrUndefined(value, 'string');\n        this.bufferText = this.bufferText + value + '\\r\\n';\n        if (this.bufferText.length >= 10240) {\n            this.flush();\n        }\n    };\n    /**\n     * Releases the resources used by the StreamWriter\n     * @returns {void}\n     */\n    StreamWriter.prototype.destroy = function () {\n        this.bufferBlob = undefined;\n        this.bufferText = undefined;\n        if (this.enc instanceof Encoding) {\n            this.enc.destroy();\n        }\n        this.enc = undefined;\n    };\n    return StreamWriter;\n}());\nexport { StreamWriter };\n","import { Encoding } from '@syncfusion/ej2-file-utils';\n/**\n * array literal codes\n */\nvar arrLiteralCodes = new Int16Array(286);\nvar arrLiteralLengths = new Uint8Array(286);\nvar arrDistanceCodes = new Int16Array(30);\nvar arrDistanceLengths = new Uint8Array(30);\n/**\n * represent compression stream writer\n * ```typescript\n * let compressedWriter = new CompressedStreamWriter();\n * let text: string = 'Hello world!!!';\n * compressedWriter.write(text, 0, text.length);\n * compressedWriter.close();\n * ```\n */\nvar CompressedStreamWriter = /** @class */ (function () {\n    /**\n     * Initializes compressor and writes ZLib header if needed.\n     * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n     */\n    function CompressedStreamWriter(noWrap) {\n        this.pendingBuffer = new Uint8Array(1 << 16);\n        this.pendingBufLength = 0;\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.currentHash = 0;\n        this.matchStart = 0;\n        this.matchLength = 0;\n        this.matchPrevAvail = false;\n        this.blockStart = 0;\n        this.stringStart = 0;\n        this.lookAhead = 0;\n        this.totalBytesIn = 0;\n        this.inputOffset = 0;\n        this.inputEnd = 0;\n        this.windowSize = 1 << 15;\n        this.windowMask = this.windowSize - 1;\n        this.hashSize = 1 << 15;\n        this.hashMask = this.hashSize - 1;\n        this.hashShift = Math.floor((15 + 3 - 1) / 3);\n        this.maxDist = this.windowSize - 262;\n        this.checkSum = 1;\n        this.noWrap = false;\n        this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);\n        this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);\n        this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);\n        this.arrDistances = new Uint16Array((1 << 14));\n        this.arrLiterals = new Uint8Array((1 << 14));\n        this.stream = [];\n        this.dataWindow = new Uint8Array(2 * this.windowSize);\n        this.hashHead = new Int16Array(this.hashSize);\n        this.hashPrevious = new Int16Array(this.windowSize);\n        this.blockStart = this.stringStart = 1;\n        this.noWrap = noWrap;\n        if (!noWrap) {\n            this.writeZLibHeader();\n        }\n    }\n    Object.defineProperty(CompressedStreamWriter.prototype, \"compressedData\", {\n        /**\n         * get compressed data\n         */\n        get: function () {\n            return this.stream;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressedStreamWriter.prototype, \"getCompressedString\", {\n        get: function () {\n            var compressedString = '';\n            if (this.stream !== undefined) {\n                for (var i = 0; i < this.stream.length; i++) {\n                    compressedString += String.fromCharCode.apply(null, this.stream[i]);\n                }\n            }\n            return compressedString;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Compresses data and writes it to the stream.\n     * @param {Uint8Array} data - data to compress\n     * @param {number} offset - offset in data\n     * @param {number} length - length of the data\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.write = function (data, offset, length) {\n        if (data === undefined || data === null) {\n            throw new Error('ArgumentException: data cannot null or undefined');\n        }\n        var end = offset + length;\n        if (0 > offset || offset > end || end > data.length) {\n            throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');\n        }\n        if (typeof data === 'string') {\n            var encode = new Encoding(false);\n            encode.type = 'Utf8';\n            data = new Uint8Array(encode.getBytes(data, 0, data.length));\n            end = offset + data.length;\n        }\n        this.inputBuffer = data;\n        this.inputOffset = offset;\n        this.inputEnd = end;\n        if (!this.noWrap) {\n            this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);\n        }\n        while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {\n            this.pendingBufferFlush();\n            this.compressData(false);\n        }\n    };\n    /**\n     * write ZLib header to the compressed data\n     * @return {void}\n     */\n    CompressedStreamWriter.prototype.writeZLibHeader = function () {\n        /* Initialize header.*/\n        var headerDate = (8 + (7 << 4)) << 8;\n        /* Save compression level.*/\n        headerDate |= ((5 >> 2) & 3) << 6;\n        /* Align header.*/\n        headerDate += 31 - (headerDate % 31);\n        /* Write header to stream.*/\n        this.pendingBufferWriteShortBytes(headerDate);\n    };\n    /**\n     *  Write Most Significant Bytes in to stream\n     * @param {number} s - check sum value\n     */\n    CompressedStreamWriter.prototype.pendingBufferWriteShortBytes = function (s) {\n        this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n        this.pendingBuffer[this.pendingBufLength++] = s;\n    };\n    CompressedStreamWriter.prototype.compressData = function (finish) {\n        var success;\n        do {\n            this.fillWindow();\n            var canFlush = (finish && this.inputEnd === this.inputOffset);\n            success = this.compressSlow(canFlush, finish);\n        } while (this.pendingBufLength === 0 && success);\n        return success;\n    };\n    CompressedStreamWriter.prototype.compressSlow = function (flush, finish) {\n        if (this.lookAhead < 262 && !flush) {\n            return false;\n        }\n        while (this.lookAhead >= 262 || flush) {\n            if (this.lookAhead === 0) {\n                return this.lookAheadCompleted(finish);\n            }\n            if (this.stringStart >= 2 * this.windowSize - 262) {\n                this.slideWindow();\n            }\n            var prevMatch = this.matchStart;\n            var prevLen = this.matchLength;\n            if (this.lookAhead >= 3) {\n                this.discardMatch();\n            }\n            if (prevLen >= 3 && this.matchLength <= prevLen) {\n                prevLen = this.matchPreviousBest(prevMatch, prevLen);\n            }\n            else {\n                this.matchPreviousAvailable();\n            }\n            if (this.bufferPosition >= (1 << 14)) {\n                return this.huffmanIsFull(finish);\n            }\n        }\n        return true;\n    };\n    CompressedStreamWriter.prototype.discardMatch = function () {\n        var hashHead = this.insertString();\n        if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {\n            if (this.matchLength <= 5 && (this.matchLength === 3 && this.stringStart - this.matchStart > 4096)) {\n                this.matchLength = 3 - 1;\n            }\n        }\n    };\n    CompressedStreamWriter.prototype.matchPreviousAvailable = function () {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = true;\n        this.stringStart++;\n        this.lookAhead--;\n    };\n    CompressedStreamWriter.prototype.matchPreviousBest = function (prevMatch, prevLen) {\n        this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);\n        prevLen -= 2;\n        do {\n            this.stringStart++;\n            this.lookAhead--;\n            if (this.lookAhead >= 3) {\n                this.insertString();\n            }\n        } while (--prevLen > 0);\n        this.stringStart++;\n        this.lookAhead--;\n        this.matchPrevAvail = false;\n        this.matchLength = 3 - 1;\n        return prevLen;\n    };\n    CompressedStreamWriter.prototype.lookAheadCompleted = function (finish) {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = false;\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);\n        this.blockStart = this.stringStart;\n        return false;\n    };\n    CompressedStreamWriter.prototype.huffmanIsFull = function (finish) {\n        var len = this.stringStart - this.blockStart;\n        if (this.matchPrevAvail) {\n            len--;\n        }\n        var lastBlock = (finish && this.lookAhead === 0 && !this.matchPrevAvail);\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);\n        this.blockStart += len;\n        return !lastBlock;\n    };\n    CompressedStreamWriter.prototype.fillWindow = function () {\n        if (this.stringStart >= this.windowSize + this.maxDist) {\n            this.slideWindow();\n        }\n        while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {\n            var more = 2 * this.windowSize - this.lookAhead - this.stringStart;\n            if (more > this.inputEnd - this.inputOffset) {\n                more = this.inputEnd - this.inputOffset;\n            }\n            this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);\n            this.inputOffset += more;\n            this.totalBytesIn += more;\n            this.lookAhead += more;\n        }\n        if (this.lookAhead >= 3) {\n            this.updateHash();\n        }\n    };\n    CompressedStreamWriter.prototype.slideWindow = function () {\n        this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);\n        this.matchStart -= this.windowSize;\n        this.stringStart -= this.windowSize;\n        this.blockStart -= this.windowSize;\n        for (var i = 0; i < this.hashSize; ++i) {\n            var m = this.hashHead[i] & 0xffff;\n            this.hashHead[i] = (((m >= this.windowSize) ? (m - this.windowSize) : 0));\n        }\n        for (var i = 0; i < this.windowSize; i++) {\n            var m = this.hashPrevious[i] & 0xffff;\n            this.hashPrevious[i] = ((m >= this.windowSize) ? (m - this.windowSize) : 0);\n        }\n    };\n    CompressedStreamWriter.prototype.insertString = function () {\n        var match;\n        var hash = ((this.currentHash << this.hashShift) ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;\n        this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];\n        this.hashHead[hash] = this.stringStart;\n        this.currentHash = hash;\n        return match & 0xffff;\n    };\n    CompressedStreamWriter.prototype.findLongestMatch = function (curMatch) {\n        var chainLen = 4096;\n        var niceLen = 258;\n        var scan = this.stringStart;\n        var match;\n        var bestEnd = this.stringStart + this.matchLength;\n        var bestLength = Math.max(this.matchLength, 3 - 1);\n        var limit = Math.max(this.stringStart - this.maxDist, 0);\n        var stringEnd = this.stringStart + 258 - 1;\n        var scanEnd1 = this.dataWindow[bestEnd - 1];\n        var scanEnd = this.dataWindow[bestEnd];\n        var data = this.dataWindow;\n        if (bestLength >= 32) {\n            chainLen >>= 2;\n        }\n        if (niceLen > this.lookAhead) {\n            niceLen = this.lookAhead;\n        }\n        do {\n            if (data[curMatch + bestLength] !== scanEnd ||\n                data[curMatch + bestLength - 1] !== scanEnd1 ||\n                data[curMatch] !== data[scan] ||\n                data[curMatch + 1] !== data[scan + 1]) {\n                continue;\n            }\n            match = curMatch + 2;\n            scan += 2;\n            /* tslint:disable */\n            while (data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {\n                /* tslint:disable */\n            }\n            if (scan > bestEnd) {\n                this.matchStart = curMatch;\n                bestEnd = scan;\n                bestLength = scan - this.stringStart;\n                if (bestLength >= niceLen) {\n                    break;\n                }\n                scanEnd1 = data[bestEnd - 1];\n                scanEnd = data[bestEnd];\n            }\n            scan = this.stringStart;\n        } while ((curMatch = (this.hashPrevious[curMatch & this.windowMask] & 0xffff)) > limit && --chainLen !== 0);\n        this.matchLength = Math.min(bestLength, this.lookAhead);\n        return this.matchLength >= 3;\n    };\n    CompressedStreamWriter.prototype.updateHash = function () {\n        this.currentHash = (this.dataWindow[this.stringStart] << this.hashShift) ^ this.dataWindow[this.stringStart + 1];\n    };\n    CompressedStreamWriter.prototype.huffmanTallyLit = function (literal) {\n        this.arrDistances[this.bufferPosition] = 0;\n        this.arrLiterals[this.bufferPosition++] = literal;\n        this.treeLiteral.codeFrequencies[literal]++;\n        return this.bufferPosition >= (1 << 14);\n    };\n    CompressedStreamWriter.prototype.huffmanTallyDist = function (dist, len) {\n        this.arrDistances[this.bufferPosition] = dist;\n        this.arrLiterals[this.bufferPosition++] = (len - 3);\n        var lc = this.huffmanLengthCode(len - 3);\n        this.treeLiteral.codeFrequencies[lc]++;\n        if (lc >= 265 && lc < 285) {\n            this.extraBits += Math.floor((lc - 261) / 4);\n        }\n        var dc = this.huffmanDistanceCode(dist - 1);\n        this.treeDistances.codeFrequencies[dc]++;\n        if (dc >= 4) {\n            this.extraBits += Math.floor((dc / 2 - 1));\n        }\n        return this.bufferPosition >= (1 << 14);\n    };\n    CompressedStreamWriter.prototype.huffmanFlushBlock = function (stored, storedOffset, storedLength, lastBlock) {\n        this.treeLiteral.codeFrequencies[256]++;\n        this.treeLiteral.buildTree();\n        this.treeDistances.buildTree();\n        this.treeLiteral.calculateBLFreq(this.treeCodeLengths);\n        this.treeDistances.calculateBLFreq(this.treeCodeLengths);\n        this.treeCodeLengths.buildTree();\n        var blTreeCodes = 4;\n        for (var i = 18; i > blTreeCodes; i--) {\n            if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {\n                blTreeCodes = i + 1;\n            }\n        }\n        var opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() +\n            this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;\n        var static_len = this.extraBits;\n        for (var i = 0; i < 286; i++) {\n            static_len += this.treeLiteral.codeFrequencies[i] * arrLiteralLengths[i];\n        }\n        for (var i = 0; i < 30; i++) {\n            static_len += this.treeDistances.codeFrequencies[i] * arrDistanceLengths[i];\n        }\n        if (opt_len >= static_len) {\n            // Force static trees.\n            opt_len = static_len;\n        }\n        if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {\n            this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);\n        }\n        else if (opt_len == static_len) {\n            // Encode with static tree.\n            this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);\n            this.treeLiteral.setStaticCodes(arrLiteralCodes, arrLiteralLengths);\n            this.treeDistances.setStaticCodes(arrDistanceCodes, arrDistanceLengths);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n        else {\n            this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);\n            this.huffmanSendAllTrees(blTreeCodes);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n    };\n    CompressedStreamWriter.prototype.huffmanFlushStoredBlock = function (stored, storedOffset, storedLength, lastBlock) {\n        this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);\n        this.pendingBufferAlignToByte();\n        this.pendingBufferWriteShort(storedLength);\n        this.pendingBufferWriteShort(~storedLength);\n        this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);\n        this.huffmanReset();\n    };\n    CompressedStreamWriter.prototype.huffmanLengthCode = function (len) {\n        if (len === 255) {\n            return 285;\n        }\n        var code = 257;\n        while (len >= 8) {\n            code += 4;\n            len >>= 1;\n        }\n        return code + len;\n    };\n    CompressedStreamWriter.prototype.huffmanDistanceCode = function (distance) {\n        var code = 0;\n        while (distance >= 4) {\n            code += 2;\n            distance >>= 1;\n        }\n        return code + distance;\n    };\n    CompressedStreamWriter.prototype.huffmanSendAllTrees = function (blTreeCodes) {\n        this.treeCodeLengths.buildCodes();\n        this.treeLiteral.buildCodes();\n        this.treeDistances.buildCodes();\n        this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);\n        this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);\n        this.pendingBufferWriteBits(blTreeCodes - 4, 4);\n        for (var rank = 0; rank < blTreeCodes; rank++) {\n            this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);\n        }\n        this.treeLiteral.writeTree(this.treeCodeLengths);\n        this.treeDistances.writeTree(this.treeCodeLengths);\n    };\n    CompressedStreamWriter.prototype.huffmanReset = function () {\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.treeLiteral.reset();\n        this.treeDistances.reset();\n        this.treeCodeLengths.reset();\n    };\n    CompressedStreamWriter.prototype.huffmanCompressBlock = function () {\n        for (var i = 0; i < this.bufferPosition; i++) {\n            var literalLen = this.arrLiterals[i] & 255;\n            var dist = this.arrDistances[i];\n            if (dist-- !== 0) {\n                var lc = this.huffmanLengthCode(literalLen);\n                this.treeLiteral.writeCodeToStream(lc);\n                var bits = Math.floor((lc - 261) / 4);\n                if (bits > 0 && bits <= 5) {\n                    this.pendingBufferWriteBits(literalLen & ((1 << bits) - 1), bits);\n                }\n                var dc = this.huffmanDistanceCode(dist);\n                this.treeDistances.writeCodeToStream(dc);\n                bits = Math.floor(dc / 2 - 1);\n                if (bits > 0) {\n                    this.pendingBufferWriteBits(dist & ((1 << bits) - 1), bits);\n                }\n            }\n            else {\n                this.treeLiteral.writeCodeToStream(literalLen);\n            }\n        }\n        this.treeLiteral.writeCodeToStream(256);\n    };\n    /**\n     * write bits in to internal buffer\n     * @param {number} b - source of bits\n     * @param {number} count - count of bits to write\n     */\n    CompressedStreamWriter.prototype.pendingBufferWriteBits = function (b, count) {\n        var uint = new Uint32Array(1);\n        uint[0] = this.pendingBufCache | (b << this.pendingBufBitsInCache);\n        this.pendingBufCache = uint[0];\n        this.pendingBufBitsInCache += count;\n        this.pendingBufferFlushBits();\n    };\n    CompressedStreamWriter.prototype.pendingBufferFlush = function (isClose) {\n        this.pendingBufferFlushBits();\n        if (this.pendingBufLength > 0) {\n            var array = new Uint8Array(this.pendingBufLength);\n            array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);\n            this.stream.push(array);\n        }\n        this.pendingBufLength = 0;\n    };\n    CompressedStreamWriter.prototype.pendingBufferFlushBits = function () {\n        var result = 0;\n        while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < (1 << 16)) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n            this.pendingBufCache >>= 8;\n            this.pendingBufBitsInCache -= 8;\n            result++;\n        }\n        return result;\n    };\n    CompressedStreamWriter.prototype.pendingBufferWriteByteBlock = function (data, offset, length) {\n        var array = data.subarray(offset, offset + length);\n        this.pendingBuffer.set(array, this.pendingBufLength);\n        this.pendingBufLength += length;\n    };\n    CompressedStreamWriter.prototype.pendingBufferWriteShort = function (s) {\n        this.pendingBuffer[this.pendingBufLength++] = s;\n        this.pendingBuffer[this.pendingBufLength++] = (s >> 8);\n    };\n    CompressedStreamWriter.prototype.pendingBufferAlignToByte = function () {\n        if (this.pendingBufBitsInCache > 0) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n        }\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n    };\n    /**\n     * close the stream and write all pending buffer in to stream\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.close = function () {\n        do {\n            this.pendingBufferFlush(true);\n            if (!this.compressData(true)) {\n                this.pendingBufferFlush(true);\n                this.pendingBufferAlignToByte();\n                if (!this.noWrap) {\n                    this.pendingBufferWriteShortBytes(this.checkSum >> 16);\n                    this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);\n                }\n                this.pendingBufferFlush(true);\n            }\n        } while (!(this.inputEnd === this.inputOffset) ||\n            !(this.pendingBufLength === 0));\n    };\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.destroy = function () {\n        this.stream = [];\n        this.stream = undefined;\n        this.pendingBuffer = undefined;\n        this.treeLiteral = undefined;\n        this.treeDistances = undefined;\n        this.treeCodeLengths = undefined;\n        this.arrLiterals = undefined;\n        this.arrDistances = undefined;\n        this.hashHead = undefined;\n        this.hashPrevious = undefined;\n        this.dataWindow = undefined;\n        this.inputBuffer = undefined;\n        this.pendingBufLength = undefined;\n        this.pendingBufCache = undefined;\n        this.pendingBufBitsInCache = undefined;\n        this.bufferPosition = undefined;\n        this.extraBits = undefined;\n        this.currentHash = undefined;\n        this.matchStart = undefined;\n        this.matchLength = undefined;\n        this.matchPrevAvail = undefined;\n        this.blockStart = undefined;\n        this.stringStart = undefined;\n        this.lookAhead = undefined;\n        this.totalBytesIn = undefined;\n        this.inputOffset = undefined;\n        this.inputEnd = undefined;\n        this.windowSize = undefined;\n        this.windowMask = undefined;\n        this.hashSize = undefined;\n        this.hashMask = undefined;\n        this.hashShift = undefined;\n        this.maxDist = undefined;\n        this.checkSum = undefined;\n        this.noWrap = undefined;\n    };\n    return CompressedStreamWriter;\n}());\nexport { CompressedStreamWriter };\n/**\n * represent the Huffman Tree\n */\nvar CompressorHuffmanTree = /** @class */ (function () {\n    /**\n     * Create new Huffman Tree\n     * @param {CompressedStreamWriter} writer instance\n     * @param {number} elementCount - element count\n     * @param {number} minCodes - minimum count\n     * @param {number} maxLength - maximum count\n     */\n    function CompressorHuffmanTree(writer, elementCount, minCodes, maxLength) {\n        this.writer = writer;\n        this.codeMinCount = minCodes;\n        this.maxLength = maxLength;\n        this.codeFrequency = new Uint16Array(elementCount);\n        this.lengthCount = new Int32Array(maxLength);\n    }\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"treeLength\", {\n        get: function () {\n            return this.codeCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"codeLengths\", {\n        get: function () {\n            return this.codeLength;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"codeFrequencies\", {\n        get: function () {\n            return this.codeFrequency;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CompressorHuffmanTree.prototype.setStaticCodes = function (codes, lengths) {\n        var temp = new Int16Array(codes.length);\n        temp.set(codes, 0);\n        this.codes = temp;\n        var lengthTemp = new Uint8Array(lengths.length);\n        lengthTemp.set(lengths, 0);\n        this.codeLength = lengthTemp;\n    };\n    /**\n     * reset all code data in tree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.reset = function () {\n        for (var i = 0; i < this.codeFrequency.length; i++) {\n            this.codeFrequency[i] = 0;\n        }\n        this.codes = undefined;\n        this.codeLength = undefined;\n    };\n    /**\n     * write code to the compressor output stream\n     * @param {number} code - code to be written\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.writeCodeToStream = function (code) {\n        this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);\n    };\n    /**\n     * calculate code from their frequencies\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.buildCodes = function () {\n        var nextCode = new Int32Array(this.maxLength);\n        this.codes = new Int16Array(this.codeCount);\n        var code = 0;\n        for (var bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {\n            nextCode[bitsCount] = code;\n            code += this.lengthCount[bitsCount] << (15 - bitsCount);\n        }\n        for (var i = 0; i < this.codeCount; i++) {\n            var bits = this.codeLength[i];\n            if (bits > 0) {\n                this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);\n                nextCode[bits - 1] += 1 << (16 - bits);\n            }\n        }\n    };\n    CompressorHuffmanTree.bitReverse = function (value) {\n        return (CompressorHuffmanTree.reverseBits[value & 15] << 12\n            | CompressorHuffmanTree.reverseBits[(value >> 4) & 15] << 8\n            | CompressorHuffmanTree.reverseBits[(value >> 8) & 15] << 4\n            | CompressorHuffmanTree.reverseBits[value >> 12]);\n    };\n    /**\n     * calculate length of compressed data\n     * @returns {number}\n     */\n    CompressorHuffmanTree.prototype.getEncodedLength = function () {\n        var len = 0;\n        for (var i = 0; i < this.codeFrequency.length; i++) {\n            len += this.codeFrequency[i] * this.codeLength[i];\n        }\n        return len;\n    };\n    /**\n     * calculate code frequencies\n     * @param {CompressorHuffmanTree} blTree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.calculateBLFreq = function (blTree) {\n        var maxCount;\n        var minCount;\n        var count;\n        var curLen = -1;\n        var i = 0;\n        while (i < this.codeCount) {\n            count = 1;\n            var nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxCount = 138;\n                minCount = 3;\n            }\n            else {\n                maxCount = 6;\n                minCount = 3;\n                if (curLen !== nextLen) {\n                    blTree.codeFrequency[nextLen]++;\n                    count = 0;\n                }\n            }\n            curLen = nextLen;\n            i++;\n            while (i < this.codeCount && curLen === this.codeLength[i]) {\n                i++;\n                if (++count >= maxCount) {\n                    break;\n                }\n            }\n            if (count < minCount) {\n                blTree.codeFrequency[curLen] += count;\n            }\n            else if (curLen !== 0) {\n                blTree.codeFrequency[16]++;\n            }\n            else if (count <= 10) {\n                blTree.codeFrequency[17]++;\n            }\n            else {\n                blTree.codeFrequency[18]++;\n            }\n        }\n    };\n    /**\n     * @param {CompressorHuffmanTree} blTree - write tree to output stream\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.writeTree = function (blTree) {\n        var maxRepeatCount;\n        var minRepeatCount;\n        var currentRepeatCount;\n        var currentCodeLength = -1;\n        var i = 0;\n        while (i < this.codeCount) {\n            currentRepeatCount = 1;\n            var nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxRepeatCount = 138;\n                minRepeatCount = 3;\n            }\n            else {\n                maxRepeatCount = 6;\n                minRepeatCount = 3;\n                if (currentCodeLength !== nextLen) {\n                    blTree.writeCodeToStream(nextLen);\n                    currentRepeatCount = 0;\n                }\n            }\n            currentCodeLength = nextLen;\n            i++;\n            while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {\n                i++;\n                if (++currentRepeatCount >= maxRepeatCount) {\n                    break;\n                }\n            }\n            if (currentRepeatCount < minRepeatCount) {\n                while (currentRepeatCount-- > 0) {\n                    blTree.writeCodeToStream(currentCodeLength);\n                }\n            }\n            else if (currentCodeLength !== 0) {\n                blTree.writeCodeToStream(16);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);\n            }\n            else if (currentRepeatCount <= 10) {\n                blTree.writeCodeToStream(17);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);\n            }\n            else {\n                blTree.writeCodeToStream(18);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);\n            }\n        }\n    };\n    /**\n     * Build huffman tree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.buildTree = function () {\n        var codesCount = this.codeFrequency.length;\n        var arrTree = new Int32Array(codesCount);\n        var treeLength = 0;\n        var maxCount = 0;\n        for (var n = 0; n < codesCount; n++) {\n            var freq = this.codeFrequency[n];\n            if (freq !== 0) {\n                var pos = treeLength++;\n                var pPos = 0;\n                while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {\n                    arrTree[pos] = arrTree[pPos];\n                    pos = pPos;\n                }\n                arrTree[pos] = n;\n                maxCount = n;\n            }\n        }\n        while (treeLength < 2) {\n            arrTree[treeLength++] =\n                (maxCount < 2) ? ++maxCount : 0;\n        }\n        this.codeCount = Math.max(maxCount + 1, this.codeMinCount);\n        var leafsCount = treeLength;\n        var nodesCount = leafsCount;\n        var child = new Int32Array(4 * treeLength - 2);\n        var values = new Int32Array(2 * treeLength - 1);\n        for (var i = 0; i < treeLength; i++) {\n            var node = arrTree[i];\n            var iIndex = 2 * i;\n            child[iIndex] = node;\n            child[iIndex + 1] = -1;\n            values[i] = (this.codeFrequency[node] << 8);\n            arrTree[i] = i;\n        }\n        this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);\n        this.buildLength(child);\n    };\n    CompressorHuffmanTree.prototype.constructHuffmanTree = function (arrTree, treeLength, values, nodesCount, child) {\n        do {\n            var first = arrTree[0];\n            var last = arrTree[--treeLength];\n            var lastVal = values[last];\n            var pPos = 0;\n            var path = 1;\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            }\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n            var second = arrTree[0];\n            last = nodesCount++;\n            child[2 * last] = first;\n            child[2 * last + 1] = second;\n            var minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);\n            values[last] = lastVal = values[first] + values[second] - minDepth + 1;\n            pPos = 0;\n            path = 1;\n            /* tslint:disable */\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            } /* tslint:disable */\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n        } while (treeLength > 1);\n    };\n    CompressorHuffmanTree.prototype.buildLength = function (child) {\n        this.codeLength = new Uint8Array(this.codeFrequency.length);\n        var numNodes = Math.floor(child.length / 2);\n        var numLeafs = Math.floor((numNodes + 1) / 2);\n        var overflow = 0;\n        for (var i = 0; i < this.maxLength; i++) {\n            this.lengthCount[i] = 0;\n        }\n        overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);\n        if (overflow === 0) {\n            return;\n        }\n        var iIncreasableLength = this.maxLength - 1;\n        do {\n            while (this.lengthCount[--iIncreasableLength] === 0) {\n                /* tslint:disable */\n            }\n            do {\n                this.lengthCount[iIncreasableLength]--;\n                this.lengthCount[++iIncreasableLength]++;\n                overflow -= (1 << (this.maxLength - 1 - iIncreasableLength));\n            } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);\n        } while (overflow > 0);\n        this.recreateTree(child, overflow, numLeafs);\n    };\n    CompressorHuffmanTree.prototype.recreateTree = function (child, overflow, numLeafs) {\n        this.lengthCount[this.maxLength - 1] += overflow;\n        this.lengthCount[this.maxLength - 2] -= overflow;\n        var nodePtr = 2 * numLeafs;\n        for (var bits = this.maxLength; bits !== 0; bits--) {\n            var n = this.lengthCount[bits - 1];\n            while (n > 0) {\n                var childPtr = 2 * child[nodePtr++];\n                if (child[childPtr + 1] === -1) {\n                    this.codeLength[child[childPtr]] = bits;\n                    n--;\n                }\n            }\n        }\n    };\n    CompressorHuffmanTree.prototype.calculateOptimalCodeLength = function (child, overflow, numNodes) {\n        var lengths = new Int32Array(numNodes);\n        lengths[numNodes - 1] = 0;\n        for (var i = numNodes - 1; i >= 0; i--) {\n            var childIndex = 2 * i + 1;\n            if (child[childIndex] !== -1) {\n                var bitLength = lengths[i] + 1;\n                if (bitLength > this.maxLength) {\n                    bitLength = this.maxLength;\n                    overflow++;\n                }\n                lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;\n            }\n            else {\n                var bitLength = lengths[i];\n                this.lengthCount[bitLength - 1]++;\n                this.codeLength[child[childIndex - 1]] = lengths[i];\n            }\n        }\n        return overflow;\n    };\n    CompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n    CompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n    return CompressorHuffmanTree;\n}());\nexport { CompressorHuffmanTree };\n/**\n * Checksum calculator, based on Adler32 algorithm.\n */\nvar ChecksumCalculator = /** @class */ (function () {\n    function ChecksumCalculator() {\n    }\n    /**\n     * Updates checksum by calculating checksum of the\n     * given buffer and adding it to current value.\n     * @param {number} checksum - current checksum.\n     * @param {Uint8Array} buffer - data byte array.\n     * @param {number} offset - offset in the buffer.\n     * @param {number} length - length of data to be used from the stream.\n     * @returns {number}\n     */\n    ChecksumCalculator.checksumUpdate = function (checksum, buffer, offset, length) {\n        var uint = new Uint32Array(1);\n        uint[0] = checksum;\n        var checksum_uint = uint[0];\n        var s1 = uint[0] = checksum_uint & 65535;\n        var s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;\n        while (length > 0) {\n            var steps = Math.min(length, ChecksumCalculator.checksumIterationCount);\n            length -= steps;\n            while (--steps >= 0) {\n                s1 = s1 + (uint[0] = (buffer[offset++] & 255));\n                s2 = s2 + s1;\n            }\n            s1 %= ChecksumCalculator.checksumBase;\n            s2 %= ChecksumCalculator.checksumBase;\n        }\n        checksum_uint = (s2 << ChecksumCalculator.checkSumBitOffset) | s1;\n        return checksum_uint;\n    };\n    ChecksumCalculator.checkSumBitOffset = 16;\n    ChecksumCalculator.checksumBase = 65521;\n    ChecksumCalculator.checksumIterationCount = 3800;\n    return ChecksumCalculator;\n}());\nexport { ChecksumCalculator };\n/**\n * Huffman Tree literal calculation\n */\n(function () {\n    var i = 0;\n    while (i < 144) {\n        arrLiteralCodes[i] = CompressorHuffmanTree.bitReverse((0x030 + i) << 8);\n        arrLiteralLengths[i++] = 8;\n    }\n    while (i < 256) {\n        arrLiteralCodes[i] = CompressorHuffmanTree.bitReverse((0x190 - 144 + i) << 7);\n        arrLiteralLengths[i++] = 9;\n    }\n    while (i < 280) {\n        arrLiteralCodes[i] = CompressorHuffmanTree.bitReverse((0x000 - 256 + i) << 9);\n        arrLiteralLengths[i++] = 7;\n    }\n    while (i < 286) {\n        arrLiteralCodes[i] = CompressorHuffmanTree.bitReverse((0x0c0 - 280 + i) << 8);\n        arrLiteralLengths[i++] = 8;\n    }\n    for (i = 0; i < 30; i++) {\n        arrDistanceCodes[i] = CompressorHuffmanTree.bitReverse(i << 11);\n        arrDistanceLengths[i] = 5;\n    }\n})();\n","import { CompressedStreamWriter } from './compression-writer';\nimport { Save } from '@syncfusion/ej2-file-utils';\nvar crc32Table = [];\n/**\n * class provide compression library\n * ```typescript\n * let archive = new ZipArchive();\n * archive.compressionLevel = 'Normal';\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * archive.addItem(archiveItem);\n * archive.save(fileName.zip);\n * ```\n */\nvar ZipArchive = /** @class */ (function () {\n    /**\n     * constructor for creating ZipArchive instance\n     */\n    function ZipArchive() {\n        this.files = [];\n        this.level = 'Normal';\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    Object.defineProperty(ZipArchive.prototype, \"compressionLevel\", {\n        /**\n         * gets compression level\n         */\n        get: function () {\n            return this.level;\n        },\n        /**\n         * sets compression level\n         */\n        set: function (level) {\n            this.level = level;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZipArchive.prototype, \"length\", {\n        /**\n         * gets items count\n         */\n        get: function () {\n            if (this.files === undefined) {\n                return 0;\n            }\n            return this.files.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * add new item to archive\n     * @param {ZipArchiveItem} item - item to be added\n     * @returns {void}\n     */\n    ZipArchive.prototype.addItem = function (item) {\n        if (item === null || item === undefined) {\n            throw new Error('ArgumentException: item cannot be null or undefined');\n        }\n        for (var i = 0; i < this.files.length; i++) {\n            var file = this.files[i];\n            if (file instanceof ZipArchiveItem) {\n                if (file.name === item.name) {\n                    throw new Error('item with same name already exist');\n                }\n            }\n        }\n        this.files.push(item);\n    };\n    /**\n     * add new directory to archive\n     * @param directoryName directoryName to be created\n     * @returns {void}\n     */\n    ZipArchive.prototype.addDirectory = function (directoryName) {\n        if (directoryName === null || directoryName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (directoryName.length === 0) {\n            throw new Error('ArgumentException: string cannot be empty');\n        }\n        if (directoryName.slice(-1) !== '/') {\n            directoryName += '/';\n        }\n        if (this.files.indexOf(directoryName) !== -1) {\n            throw new Error('item with same name already exist');\n        }\n        this.files.push(directoryName);\n    };\n    /**\n     * gets item at specified index\n     * @param {number} index - item index\n     * @returns {ZipArchiveItem}\n     */\n    ZipArchive.prototype.getItem = function (index) {\n        if (index >= 0 && index < this.files.length) {\n            return this.files[index];\n        }\n        return undefined;\n    };\n    /**\n     * determines whether an element is in the collection\n     * @param {string | ZipArchiveItem} item - item to search\n     * @returns {boolean}\n     */\n    ZipArchive.prototype.contains = function (item) {\n        return this.files.indexOf(item) !== -1 ? true : false;\n    };\n    /**\n     * save archive with specified file name\n     * @param {string} fileName save archive with specified file name\n     * @returns {Promise<ZipArchive>}\n     */\n    ZipArchive.prototype.save = function (fileName) {\n        if (fileName === null || fileName === undefined || fileName.length === 0) {\n            throw new Error('ArgumentException: fileName cannot be null or undefined');\n        }\n        if (this.files.length === 0) {\n            throw new Error('InvalidOperation');\n        }\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            zipArchive.saveInternal(fileName, false).then(function () {\n                resolve(zipArchive);\n            });\n        });\n    };\n    /**\n     * Save archive as blob\n     * @return {Promise<Blob>}\n     */\n    ZipArchive.prototype.saveAsBlob = function () {\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            zipArchive.saveInternal('', true).then(function (blob) {\n                resolve(blob);\n            });\n        });\n    };\n    ZipArchive.prototype.saveInternal = function (fileName, skipFileSave) {\n        var _this = this;\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            var zipData = [];\n            var dirLength = 0;\n            for (var i = 0; i < zipArchive.files.length; i++) {\n                var compressedObject = _this.getCompressedData(_this.files[i]);\n                compressedObject.then(function (data) {\n                    dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);\n                    if (zipData.length === zipArchive.files.length) {\n                        var blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);\n                        resolve(blob);\n                    }\n                });\n            }\n        });\n    };\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    ZipArchive.prototype.destroy = function () {\n        if (this.files !== undefined && this.files.length > 0) {\n            for (var i = 0; i < this.files.length; i++) {\n                var file = this.files[i];\n                if (file instanceof ZipArchiveItem) {\n                    file.destroy();\n                }\n                file = undefined;\n            }\n            this.files = [];\n        }\n        this.files = undefined;\n        this.level = undefined;\n    };\n    ZipArchive.prototype.getCompressedData = function (item) {\n        var zipArchive = this;\n        var promise = new Promise(function (resolve, reject) {\n            if (item instanceof ZipArchiveItem) {\n                var reader_1 = new FileReader();\n                reader_1.onload = function () {\n                    var input = new Uint8Array(reader_1.result);\n                    var data = {\n                        fileName: item.name, crc32Value: 0, compressedData: [],\n                        compressedSize: undefined, uncompressedDataSize: input.length, compressionType: undefined,\n                        isDirectory: false\n                    };\n                    if (zipArchive.level === 'Normal') {\n                        zipArchive.compressData(input, data, crc32Table);\n                        var length_1 = 0;\n                        for (var i = 0; i < data.compressedData.length; i++) {\n                            length_1 += data.compressedData[i].length;\n                        }\n                        data.compressedSize = length_1;\n                        data.compressionType = '\\x08\\x00'; //Deflated = 8\n                    }\n                    else {\n                        data.compressedSize = input.length;\n                        data.crc32Value = zipArchive.calculateCrc32Value(0, input, crc32Table);\n                        data.compressionType = '\\x00\\x00'; // Stored = 0\n                        data.compressedData.push(input);\n                    }\n                    resolve(data);\n                };\n                reader_1.readAsArrayBuffer(item.data);\n            }\n            else {\n                var data = {\n                    fileName: item, crc32Value: 0, compressedData: '', compressedSize: 0, uncompressedDataSize: 0,\n                    compressionType: '\\x00\\x00', isDirectory: true\n                };\n                resolve(data);\n            }\n        });\n        return promise;\n    };\n    ZipArchive.prototype.compressData = function (input, data, crc32Table) {\n        var compressor = new CompressedStreamWriter(true);\n        var currentIndex = 0;\n        var nextIndex = 0;\n        do {\n            if (currentIndex >= input.length) {\n                compressor.close();\n                break;\n            }\n            nextIndex = Math.min(input.length, currentIndex + 16384);\n            var subArray = input.subarray(currentIndex, nextIndex);\n            data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);\n            compressor.write(subArray, 0, nextIndex - currentIndex);\n            currentIndex = nextIndex;\n        } while (currentIndex <= input.length);\n        data.compressedData = compressor.compressedData;\n        compressor.destroy();\n    };\n    ZipArchive.prototype.constructZippedObject = function (zipParts, data, dirLength, isDirectory) {\n        var extFileAttr = 0;\n        var date = new Date();\n        if (isDirectory) {\n            extFileAttr = extFileAttr | 0x00010; // directory flag\n        }\n        extFileAttr = extFileAttr | (0 & 0x3F);\n        var header = this.writeHeader(data, date);\n        var localHeader = 'PK\\x03\\x04' + header + data.fileName;\n        var centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);\n        zipParts.push({ localHeader: localHeader, centralDir: centralDir, compressedData: data });\n        return dirLength + localHeader.length + data.compressedSize;\n    };\n    ZipArchive.prototype.writeHeader = function (data, date) {\n        var zipHeader = '';\n        zipHeader += '\\x0A\\x00' + '\\x00\\x00'; // version needed to extract & general purpose bit flag\n        zipHeader += data.compressionType; // compression method Deflate=8,Stored=0\n        zipHeader += this.getBytes(this.getModifiedTime(date), 2); // last modified Time\n        zipHeader += this.getBytes(this.getModifiedDate(date), 2); // last modified date\n        zipHeader += this.getBytes(data.crc32Value, 4); // crc-32 value\n        zipHeader += this.getBytes(data.compressedSize, 4); // compressed file size\n        zipHeader += this.getBytes(data.uncompressedDataSize, 4); // uncompressed file size\n        zipHeader += this.getBytes(data.fileName.length, 2); // file name length\n        zipHeader += this.getBytes(0, 2); // extra field length\n        return zipHeader;\n    };\n    ZipArchive.prototype.writeZippedContent = function (fileName, zipData, localDirLen, skipFileSave) {\n        var cenDirLen = 0;\n        var buffer = [];\n        for (var i = 0; i < zipData.length; i++) {\n            var item = zipData[i];\n            cenDirLen += item.centralDir.length;\n            buffer.push(this.getArrayBuffer(item.localHeader));\n            while (item.compressedData.compressedData.length) {\n                buffer.push(item.compressedData.compressedData.shift().buffer);\n            }\n        }\n        for (var i = 0; i < zipData.length; i++) {\n            buffer.push(this.getArrayBuffer(zipData[i].centralDir));\n        }\n        buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));\n        var blob = new Blob(buffer, { type: 'application/zip' });\n        if (!skipFileSave) {\n            Save.save(fileName, blob);\n        }\n        return blob;\n    };\n    ZipArchive.prototype.writeCentralDirectory = function (data, localHeader, offset, externalFileAttribute) {\n        var directoryHeader = 'PK\\x01\\x02' +\n            this.getBytes(0x0014, 2) + localHeader + // inherit from file header\n            this.getBytes(0, 2) + // comment length\n            '\\x00\\x00' + '\\x00\\x00' + // internal file attributes \n            this.getBytes(externalFileAttribute, 4) + // external file attributes\n            this.getBytes(offset, 4) + // local fileHeader relative offset\n            data.fileName;\n        return directoryHeader;\n    };\n    ZipArchive.prototype.writeFooter = function (zipData, centralLength, localLength) {\n        var dirEnd = 'PK\\x05\\x06' + '\\x00\\x00' + '\\x00\\x00' +\n            this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) +\n            this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) +\n            this.getBytes(0, 2);\n        return dirEnd;\n    };\n    ZipArchive.prototype.getArrayBuffer = function (input) {\n        var a = new Uint8Array(input.length);\n        for (var j = 0; j < input.length; ++j) {\n            a[j] = input.charCodeAt(j) & 0xFF;\n        }\n        return a.buffer;\n    };\n    ZipArchive.prototype.getBytes = function (value, offset) {\n        var bytes = '';\n        for (var i = 0; i < offset; i++) {\n            bytes += String.fromCharCode(value & 0xff);\n            value = value >>> 8;\n        }\n        return bytes;\n    };\n    ZipArchive.prototype.getModifiedTime = function (date) {\n        var modTime = date.getHours();\n        modTime = modTime << 6;\n        modTime = modTime | date.getMinutes();\n        modTime = modTime << 5;\n        return modTime = modTime | date.getSeconds() / 2;\n    };\n    ZipArchive.prototype.getModifiedDate = function (date) {\n        var modiDate = date.getFullYear() - 1980;\n        modiDate = modiDate << 4;\n        modiDate = modiDate | (date.getMonth() + 1);\n        modiDate = modiDate << 5;\n        return modiDate = modiDate | date.getDate();\n    };\n    ZipArchive.prototype.calculateCrc32Value = function (crc32Value, input, crc32Table) {\n        crc32Value ^= -1;\n        for (var i = 0; i < input.length; i++) {\n            crc32Value = (crc32Value >>> 8) ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];\n        }\n        return (crc32Value ^ (-1));\n    };\n    return ZipArchive;\n}());\nexport { ZipArchive };\n/**\n * Class represent unique ZipArchive item\n * ```typescript\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * ```\n */\nvar ZipArchiveItem = /** @class */ (function () {\n    /**\n     * constructor for creating {ZipArchiveItem} instance\n     * @param {Blob|ArrayBuffer} data file data\n     * @param {itemName} itemName absolute file path\n     */\n    function ZipArchiveItem(data, itemName) {\n        if (data === null || data === undefined) {\n            throw new Error('ArgumentException: data cannot be null or undefined');\n        }\n        if (itemName === null || itemName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (itemName.length === 0) {\n            throw new Error('string cannot be empty');\n        }\n        this.data = data;\n        this.name = itemName;\n    }\n    Object.defineProperty(ZipArchiveItem.prototype, \"name\", {\n        /**\n         * Get the name of archive item\n         * @returns string\n         */\n        get: function () {\n            return this.fileName;\n        },\n        /**\n         * Set the name of archive item\n         * @param  {string} value\n         */\n        set: function (value) {\n            this.fileName = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    ZipArchiveItem.prototype.destroy = function () {\n        this.fileName = undefined;\n        this.data = undefined;\n    };\n    return ZipArchiveItem;\n}());\nexport { ZipArchiveItem };\n/**\n * construct cyclic redundancy code table\n */\n(function () {\n    var i;\n    for (var j = 0; j < 256; j++) {\n        i = j;\n        for (var k = 0; k < 8; k++) {\n            i = ((i & 1) ? (0xEDB88320 ^ (i >>> 1)) : (i >>> 1));\n        }\n        crc32Table[j] = i;\n    }\n})();\n"],"names":["validateNullOrUndefined","value","message","undefined","Error","Encoding","includeBom","this","emitBOM","encodingType","initBOM","Object","defineProperty","prototype","get","enumerable","configurable","set","getByteCount","chars","utf8Len","charCodeAt","type","getByteCountInternal","length","codePoint","isHighSurrogate","codeUnit","toCodepoint","highCodeUnit","lowCodeUnit","charIndex","charCount","byteCount","isUtf8","i","charCode","high","low","getBytes","s","RangeError","ArrayBuffer","getBytesOfUtf8Encoding","getBytesOfUnicodeEncoding","getBytesOfAnsiEncoding","getString","bytes","index","count","byteLength","out","byteCal","Uint8Array","getStringOfUtf8Encoding","byteUnicode","Uint16Array","getStringofUnicodeEncoding","j","c","String","fromCharCode","bufview","k","charcode","uint","uint16","byteUni","byte16","apply","destroy","Save","save","fileName","buffer","extension","substring","lastIndexOf","mimeType","getMimeType","Blob","isMicrosoftBrowser","navigator","msSaveBlob","downloadLink","document","createElementNS","saveInternal","hasDownloadAttribute","download","dataUrl_1","window","URL","createObjectURL","href","event_1","createEvent","initEvent","dispatchEvent","setTimeout","revokeObjectURL","url","open","location","reader_1","FileReader","onloadend","result","readAsDataURL","StreamWriter","encoding","bufferBlob","bufferText","init","flush","enc","setBomByte","arrayUnicode","uint8","arrayUtf8","utf8","write","bufferArray","writeLine","arrLiteralCodes","Int16Array","arrLiteralLengths","arrDistanceCodes","arrDistanceLengths","CompressedStreamWriter","noWrap","pendingBuffer","pendingBufLength","pendingBufCache","pendingBufBitsInCache","bufferPosition","extraBits","currentHash","matchStart","matchLength","matchPrevAvail","blockStart","stringStart","lookAhead","totalBytesIn","inputOffset","inputEnd","windowSize","windowMask","hashSize","hashMask","hashShift","Math","floor","maxDist","checkSum","treeLiteral","CompressorHuffmanTree","treeDistances","treeCodeLengths","arrDistances","arrLiterals","stream","dataWindow","hashHead","hashPrevious","writeZLibHeader","compressedString","data","offset","end","encode","inputBuffer","ChecksumCalculator","checksumUpdate","pendingBufferFlush","compressData","headerDate","pendingBufferWriteShortBytes","finish","success","fillWindow","canFlush","compressSlow","lookAheadCompleted","slideWindow","prevMatch","prevLen","discardMatch","matchPreviousBest","matchPreviousAvailable","huffmanIsFull","insertString","findLongestMatch","huffmanTallyLit","huffmanTallyDist","huffmanFlushBlock","len","lastBlock","more","subarray","updateHash","m","match","hash","curMatch","chainLen","niceLen","scan","bestEnd","bestLength","max","limit","stringEnd","scanEnd1","scanEnd","min","literal","codeFrequencies","dist","lc","huffmanLengthCode","dc","huffmanDistanceCode","stored","storedOffset","storedLength","buildTree","calculateBLFreq","blTreeCodes","codeLengths","huffCodeLengthOrders","opt_len","getEncodedLength","static_len","huffmanFlushStoredBlock","pendingBufferWriteBits","setStaticCodes","huffmanCompressBlock","huffmanReset","huffmanSendAllTrees","pendingBufferAlignToByte","pendingBufferWriteShort","pendingBufferWriteByteBlock","code","distance","buildCodes","treeLength","rank","writeTree","reset","literalLen","writeCodeToStream","bits","b","Uint32Array","pendingBufferFlushBits","isClose","array","push","close","writer","elementCount","minCodes","maxLength","codeMinCount","codeFrequency","lengthCount","Int32Array","codeCount","codeLength","codes","lengths","temp","lengthTemp","nextCode","bitsCount","bitReverse","reverseBits","blTree","maxCount","minCount","curLen","nextLen","maxRepeatCount","minRepeatCount","currentRepeatCount","currentCodeLength","codesCount","arrTree","n","freq","pos","pPos","nodesCount","child","values","node","iIndex","constructHuffmanTree","buildLength","first","last","lastVal","path","second","minDepth","numNodes","numLeafs","overflow","calculateOptimalCodeLength","iIncreasableLength","recreateTree","nodePtr","childPtr","childIndex","bitLength","checksum","checksum_uint","s1","s2","checkSumBitOffset","steps","checksumIterationCount","checksumBase","crc32Table","ZipArchive","files","level","addItem","item","file","ZipArchiveItem","name","addDirectory","directoryName","slice","indexOf","getItem","contains","zipArchive","Promise","resolve","reject","then","saveAsBlob","blob","skipFileSave","_this","zipData","dirLength","getCompressedData","constructZippedObject","isDirectory","writeZippedContent","onload","input","crc32Value","compressedData","compressedSize","uncompressedDataSize","compressionType","length_1","calculateCrc32Value","readAsArrayBuffer","compressor","currentIndex","nextIndex","subArray","zipParts","extFileAttr","date","Date","header","writeHeader","localHeader","centralDir","writeCentralDirectory","zipHeader","getModifiedTime","getModifiedDate","localDirLen","cenDirLen","getArrayBuffer","shift","writeFooter","externalFileAttribute","centralLength","localLength","a","modTime","getHours","getMinutes","getSeconds","modiDate","getFullYear","getMonth","getDate","itemName"],"mappings":"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"}